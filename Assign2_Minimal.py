import numpy, scipy.stats as stats, operator, functools
def compareProbs(a):
    if a[0] > a[1]: return 1
    else: return -1
tp = fp = tn = fn = 0 #True Positive, False Positive, True Negative, False Negative
for x,y in list(zip(map(compareProbs, list(zip([functools.reduce(operator.mul, x, float(len(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] > 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)])) / len(numpy.loadtxt("irisTraining.txt"))) for x in stats.norm.pdf(numpy.loadtxt("irisTesting.txt")[:, 0:(numpy.loadtxt("irisTraining.txt").shape[1] - 1)], numpy.mean(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] > 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)], axis=0), numpy.std(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] > 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)], axis=0))], [functools.reduce(operator.mul, x, float(len(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] < 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] )) / len(numpy.loadtxt("irisTraining.txt"))) for x in stats.norm.pdf(numpy.loadtxt("irisTesting.txt")[:, 0:(numpy.loadtxt("irisTraining.txt").shape[1] - 1)], numpy.mean(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] < 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] , axis=0), numpy.std(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] < 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] , axis=0))]))), numpy.loadtxt("irisTesting.txt")[:,(numpy.loadtxt("irisTraining.txt").shape[1] - 1)])):
    tp +=1 if x == 1 and y == 1 else 0
    tn +=1 if x == -1 and y == -1 else 0#elif x == -1 and y == -1: tn += 1
    fp +=1 if x ==1 and y == -1 else 0#elif x == 1 and y == -1: fp += 1
    fn +=1 if x == -1 and y == 1 else 0#elif x == -1 and y == 1: fn += 1
print('Accuracy: ' + str(float(tp + tn) / (len(list(zip(map(compareProbs, list(zip([functools.reduce(operator.mul, x, float(len(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] > 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)])) / len(numpy.loadtxt("irisTraining.txt"))) for x in stats.norm.pdf(numpy.loadtxt("irisTesting.txt")[:, 0:(numpy.loadtxt("irisTraining.txt").shape[1] - 1)], numpy.mean(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] > 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)], axis=0), numpy.std(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] > 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)], axis=0))], [functools.reduce(operator.mul, x, float(len(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] < 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] )) / len(numpy.loadtxt("irisTraining.txt"))) for x in stats.norm.pdf(numpy.loadtxt("irisTesting.txt")[:, 0:(numpy.loadtxt("irisTraining.txt").shape[1] - 1)], numpy.mean(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] < 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] , axis=0), numpy.std(numpy.loadtxt("irisTraining.txt")[numpy.loadtxt("irisTraining.txt")[:, (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] < 0, 0: (numpy.loadtxt("irisTraining.txt").shape[1] - 1)] , axis=0))]))), numpy.loadtxt("irisTesting.txt")[:,(numpy.loadtxt("irisTraining.txt").shape[1] - 1)]))))) + '\n' + 'tp: ' + str(tp) + '\n' + 'tn: ' + str(tn) + '\n' + 'fp: ' + str(fp) + '\n' + 'fn: ' + str(fn) + '\n' + 'Precision: ' + str(float(tp)/(tp+fp)) + '\n' + 'Recall: ' + str(float(tp)/(tp+fn)))